name: Main - Gate on Coverage (80%+) then Docker Push

on:
  push:
    branches: [ main ]

env:
  IMAGE_BACK: app-back
  IMAGE_FRONT: app-front

jobs:
  frontend:
    name: Call • Frontend Tests
    uses: ./.github/workflows/ci-frontend.yml
    with:
      node_version: "20"
      threshold: 80
    secrets: inherit  # si jamais tu lis des secrets dans le front (rare)

  backend:
    name: Call • Backend Tests
    uses: ./.github/workflows/ci-backend.yml
    with:
      java_version: "17"
      threshold: 80
    secrets: inherit

  docker-publish:
    name: Docker • Build & Push
    needs: [ frontend, backend ]
    # on ne continue que si front.ok && back.ok == true
    if: ${{ fromJSON(needs.frontend.outputs.ok) && fromJSON(needs.backend.outputs.ok) }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # Option A : multi-stage Dockerfiles qui rebuildent tout (simple)
      # -> pas besoin de récupérer les artefacts de build

      - name: Normalize Docker Hub username
        id: norm
        shell: bash
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
        run: |
          if [ -z "${DOCKERHUB_USERNAME}" ]; then
            echo "❌ Secret DOCKERHUB_USERNAME manquant."
            exit 1
          fi
          USER="$(printf '%s' "$DOCKERHUB_USERNAME" | tr -d '[:space:]')"
          USER="$(printf '%s' "$USER" | tr '[:upper:]' '[:lower:]')"
          echo "user=$USER" >> "$GITHUB_OUTPUT"

      - name: Compute tags
        id: img
        shell: bash
        run: |
          SHORT_SHA="$(echo "${GITHUB_SHA}" | cut -c1-7)"
          echo "back_repo=${{ steps.norm.outputs.user }}/${{ env.IMAGE_BACK }}" >> "$GITHUB_OUTPUT"
          echo "front_repo=${{ steps.norm.outputs.user }}/${{ env.IMAGE_FRONT }}" >> "$GITHUB_OUTPUT"
          echo "tag_latest=latest" >> "$GITHUB_OUTPUT"
          echo "tag_sha=${SHORT_SHA}" >> "$GITHUB_OUTPUT"

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ steps.norm.outputs.user }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # Backend image
      - name: Build & Push Backend
        uses: docker/build-push-action@v6
        with:
          context: ./back
          file: ./back/Dockerfile
          push: true
          tags: |
            ${{ steps.img.outputs.back_repo }}:${{ steps.img.outputs.tag_latest }}
            ${{ steps.img.outputs.back_repo }}:${{ steps.img.outputs.tag_sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # Frontend image
      - name: Build & Push Frontend
        uses: docker/build-push-action@v6
        with:
          context: ./front
          file: ./front/Dockerfile
          push: true
          tags: |
            ${{ steps.img.outputs.front_repo }}:${{ steps.img.outputs.tag_latest }}
            ${{ steps.img.outputs.front_repo }}:${{ steps.img.outputs.tag_sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # Si l’un des deux coverage < 80%, on échoue explicitement avec un message clair
  gate-fail-message:
    name: Gate failed (coverage < 80%)
    needs: [ frontend, backend ]
    if: ${{ !(fromJSON(needs.frontend.outputs.ok) && fromJSON(needs.backend.outputs.ok)) }}
    runs-on: ubuntu-latest
    steps:
      - name: Show reason
        run: |
          echo "❌ Coverage gate failed."
          echo "Frontend: ${{ needs.frontend.outputs.coverage }}%"
          echo "Backend : ${{ needs.backend.outputs.coverage }}%"
          echo "Seuil requis: 80%"
          exit 1
